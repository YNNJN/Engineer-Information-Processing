## 1과목 - 소프트웨어 설계





1. 요구사항 확인
2. 화면 설계
3. 애플리케이션 설계
4. 인터페이스 설계

---





## 3. 애플리케이션 설계

### 1. 소프트웨어 아키텍처 설계

- 골격 구조이자, SW 구성 요소들 간의 관계를 표현하는 시스템의 구조
- 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사항을 구현하는 방법을 찾는 해결 과정
- 분할 방법, 모듈에 할당될 기능, 인터페이스를 결정
- 기본 원리는 다음과 같음
  - 모듈화: 재사용, 유지관리 용이하도록 모듈 단위로 나눔
  - 추상화: 불필요한 부분을 생략하고 필요한 부분을 강조하여 모델화
    - 시스템과 유사한 모델을 만들어, 여러 요인을 테스트 가능
    - 최소 비용으로 실제 상황에 대처, 시스템의 구조 대략 파악 가능
    - 유형은 다음과 같음
      - 과정 추상화 - 수행과정 디테일 x, 전반적인 흐름만 파악
      - 데이터 추상화 - 데이터 구조를 대표할 수 있는 표현으로 대체
      - 제어 추상화 - 이벤트 발생을 대표할 수 있는 표현으로 대체
  - 단계적 분해: 하향식 설계, 분할 기법
    - 추상화의 반복에 의해 세분화됨
    - 기능에서 시작해 점차 구체화, 알고리즘과 자료구조와 같은 디테일은 나중에
  - 정보 은닉: 모듈 안에 절차와 정보가 감추어져, 다른 모듈 접근 변경 불가
    - 필요한 정보만 인터페이스 통해 주고받음
    - 모듈 독립적 수행 가능, 수정, 시험, 유지보수 용이
- 품질 속성은 다음과 같음
  - 시스템 측면
    - 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성
    - 성능은 적절하고 빠르게, 가용성은 장애 없이, 사용성은 사용하는 데 헤매지 않도록 구현하는 것
  - 비즈니스 측면
    - 시장 적시성, 비용과 혜택, 예상시스템 수명
    - 비용을 더 투자하여 유연성 높게 만들 것인지, 유연성 떨어지면 유지보수에 비용 듦
    - 수명이 길어야한다면 변경용이성, 확장성이 중요
  - 아키텍처 측면
    - 개념적 무결성, 정확성, 완결성, 구축가능성
    - 구축 가능성이란 모듈 단위 시스템을 적절하게 분배하여 유연하게 일정 변경하는 것
- 설계 과정은 다음과 같음
  - 설계 목표 설정 - 시스템 타입 결정 - 아키텍처 패턴 적용 - 서브시스템 구체화 - 검토
  - 시스템 타입은 다음의 네 가지가 있음
    - 대화형 시스템(요구 - 반응, 보통 웹)
    - 이벤트 중심 시스템(외부 상태 변화 - 동작, 전화와 비상벨)
    - 변환형 시스템(데이터 입력 - 결과 출력, 컴파일러와 네트워크 프로토콜)
    - 객체 영속형 시스템(데이터베이스 사용 - 파일 저장검색관리, 서버관리소프트웨어)





### 2. 아키텍처 패턴

- 아키텍처 설계시 참조하는 전형적 해결 방식 또는 예제
- 서브시스템과 그 역할 정의되어 있음, 서브시스템 사이 관계와 규칙이 포함됨
- 종류는 다음과 같음
  - 레이어 패턴
    - 고전, 서로 마주보는 두 개의 계층 사이에서만 상호작용
    - 상위계층이 제공자, 하위게층이 클라이언트, 위에서 아래로 흐름
    - 특정 계층만을 교체하여 시스템 개선 가능
  - 클라이언트 - 서버 패턴
    - 하나의 서버 컴포너트, 다수의 클라이언트 컴포넌트
    - 서버에 요청 <- (클라이언트) -> 사용자에 제공
    - 서버는 항상 대기상태
    - 서버와 클라이언트는 요청과 응답 위해 동기화되는 경우 제외, 독립적
  - 파이프 - 필터 패턴
    - 데이터 스트림의 절차 각 단계를 필터 컴포넌트로 캡슐화, 파이프 통해 데이터 전송
    - 재사용성 좋고 추가와 확장 용이
    - 필터 컴포넌트 재배치 하여 여러 파이프라인 구축함
    - 데이터 변환, 버퍼링, 동기화에 사용
    - UNIX의 shell이 예시
  - 모델 - 뷰 - 컨트롤러 패턴
    - 서브시스템을 3개 부분으로 구조화 함
      - 모델: 서브시스템의 핵심 기능과 데이터 보관
      - 뷰: 사용자에게 정보 표시
      - 컨트롤러: 사용자로부터의 입력을 처리
      - 각 부분이 별도의 컴포넌트라 서로 영향 x
      - 여럭개의 뷰를 만들 수 있어 대화형 애플리케이션에 적합
  - 기타 패턴
  - 마스터 - 슬레이브 패턴
    - 작업분할 - 다시 돌려받음
    - 장애허용시스템과 병렬 컴퓨팅 시스템에 활용
  - 브로커 패턴
    - 브로커 컴포넌트가 컴포넌트와 사용자 연결
    - 응답하는 컴포넌트가 여러 개 있을 때 적합, 분산 환경 시스템에서 주로 활용
  - 피어 - 투 - 피어 패턴
    - 피어가 하나의 컴포넌트, 클라이언트가 될 수도, 서버가 될 수도 있음
    - 클라이언트와 서버는 전형적 멀티스레딩 방식 사용
    - 멀티스레딩이란 프로세스를 두 개 이상의 실행 단위로 구분, 자원 공유, 병렬 수행
  - 이벤트 - 버스 패턴
    - 소스가 이벤트 메시지 발행 - 구독한 리스너가 - 이벤트 처리
  - 블랙보드 패턴
    - 모든 컴포넌트가 공유 데이터 저장소와 블랙보드 컴포넌트에 접근 가능
    - 검색을 통해 해결책이 명확하지 않은 문제 처리함
    - 음성 인식, 차량 식별, 신호 해석에 활용
  - 인터프리터 패턴
    - 코드 줄별로 수행 방법 지정, 기호마다 클래스 가짐
    - 특정 언어로 된 코드를 해석하는 컴포넌트 설계에 활용





### 3. 객체지향

- 구조적 기법의 문제점에 대한 해결책
  - 구조적 기법이란 프로시저에 근간, 프로그램 = 데이터 + 함수
  - 객체 지향은 객체 = 데이터 + 함수, 프로그램 = 객체 + 객체
- 재사용, 확장, 빠른 개발, 유지보수 용이
- 복잡 구조를 단계적 계층적으로 표현, 병렬처리를 지원
- 객체
  - 데이터와 함수를 캠슐화한 모듈
  - 식별 가능한 이름과 상태를 가짐
  - 객체와 객체는 상호연관성에 의한 관계가 형성됨
  - 일정 기억장소를 갖고 있음
  - 메소드는 다른 객체로부터 메시지(행위)를 받았을 때 정해진 기능 수행
- 클래스
  - 공통된 속성과 행위를 갖는 객체의 집합
  - 인스턴스, Super Class, Sub Class
- 캡슐화
  - 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고, 필요한 인터페이스만을 밖으로 드러내는 과정
  - 접근이 제한적, 재사용 용이, 인터페이스 단순해지고, 객체 간 결합도 낮아짐
- 상속
  - 재사용 높이는 중요 개념
  - 다중 상속이란 두 개 이상의 상위 클래스로부터 속성과 행위를 상속받는 것
- 다형성
  - 하나의 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것
  - '+'의 경우 숫자는 덧셈, 문자는 연결함





### 4. 모듈

- 분리된 시스템, 서브루틴, 서브시스템, 프로그램, 작업 단위와 같은 의미로 사용
- 단독 컴파일, 재사용 가능
- 독립성을 높이기 위해
  - 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게
- 결합도 (약해야)
  - 여러 모듈 간 상호 의존도
  - 결합도 약한 순으로
    - 자료 결합도 - 스탬프 결합도 - 제어 결합도 - 외부 결합도 - 공통 결합도 - 내용 결합도
    - 자료결합도
      - 모듈 간 인터페이스가 자료요소로만 구성
      - 모듈 간 내용을 전혀 알 필요x, 가장 바람직
    - 스탬프 결합도
      - 모듈 간 자료구조가 전달됨
      - 두 모듈이 **동일한 자료구조를 조회**
    - 제어 결합도
      - 모듈 간 제어요소(tag, flag)를 전달
      - 권리 전도 현상이 발생할 수 있음
    - 외부 결합도
      - 어떤 모듈의 변수를 외부 모듈에서 참조할 때
    - 공통 결합도
      - 공통 데이터 영역을 여러 모듈이 사용할 때, 독립성이 약함
    - 내용 결합도
      - 다른 모듈의 기능, 자료를 직접 참조, 수정
      - 다른 모듈의 내부로 제어가 이동하는 경우에도 내용결합도에 해당
- 응집도 (강해야)
  - 하나의 모듈 안 구성 요소의 관련 정도
  - 응집도 강한 순으로
    - 기능적 응집도 - 순차적 응집도 - 교환적 응집도 - 절차적 응집도 - 시간적 응집도 - 논리적 응집도 - 우연적 응집도
    - 기능적 응집도: 모든 기능 요소가 단일 문제와 연관되어 수행
    - 순차적 응집도: 출력 데이터를 다음의 입력데이터로 사용
    - 교환적 응집도: 동일한 입출력을 사용하여 서로 다른 기능 수행
    - 절차적 응집도: 다수의 관련 기능을 가지는 모듈이 그 기능을 순차적 수행
    - 시간적 응집도: 특정 시간에 처리되는 몇 개 기능을 하나의 모듈이 처리
    - 논리적 응집도: 유사 로직을 하나의 모듈이 처리
    - 우연적 응집도: 서로 관련 없는 요소로 구성
- 팬 인 / 팬 아웃
  - 팬 인 - 선이 들어옴, 호출하는 모듈의 수
  - 팬 아웃 - 선이 나감, 호출당하는 모듈의 수
  - 이 둘을 분석하여 시스템의 복잡도 파악 가능
    - 팬 인이 높으면 재사용 굿, 단일 장애점(구성요소 동작 x -> 전체 시스템 중단)은 방지해야
    - 팬 아웃이 높으면 검토, 단순화 필요





### 5. 공통 모듈

- 공통 사용 가능 모듈, 재사용성 확보와 중복 개발 회피 위해
- 자주 사용하는 계산식, 사용자 인증 기능의 경우
- 명세기법은 다음과 같음
  - 정확성, 명확성, 완전성, 일관성, 추적성
  - 완전성 - 모든 것 기술
  - 일관성 - 상호 충돌 발생 않게
- 재사용
  - 이미 개발된 기능 파악, 재구성 -> 최적화
  - 함수와 객체의 경우, 소스코드를 재사용함
  - 컴포넌트의 경우, 컴포넌트 수정 없이 인터페이스 통신으로 재사용함
  - 애플리케이션이 경우, 공통 기능 제공하는 애플리케이션을 공유하여 재사용함
- 효과적 모듈 설계 방안
  - 결합도 줄이고 응집도 높여서 모듈의 독립성, 재사용성 높임
  - 모듈 제어영역(모듈이 제어하는 하위 모듈) 안에서 영향영역 유지함





### 6. 코드

- 주민등록번호, 학번, 전화번호 같은
- 식별, 분류, 배열 기능 존재

- 종류는 다음과 같음
  - 순차 코드 - 차례로 일련 번호
  - 블럭 코드 - 공통성 있는 것끼리 블록으로 묶음, 블록 내에서 일련번호 부여
  - 10진 코드 - 도서분류식 코드
  - 그룹 분류 코드 - 대중소분류, 그룹 안 일련번호 부여
  - 연상 코드 - 명칭, 약호와 관계있는 숫자, 문자, 기호 이용
  - 표의 숫자 코드(significant digit) - 물리적 수치 그대로 코드에 적용
  - 합성 코드 - 2개 이상의 코드 조합 (비행기, 연상코드 + 순차코드)
- 소프트웨어 개발에서 코드 부여 대상은 모듈, 컴포넌트, 인터페이스
- 코드의 자릿수와 구분자, 구조 등을 상세하게 명시해야





### 7. 디자인 패턴

- 아키텍처 패턴과 같이, 소프트웨어 설계를 위한 참조 모델
  - 아키텍처 패턴이 더 상위 수준의 설계에 사용됨
  - 아키텍처를 전체 구조 설계, 디자인 패턴은 서브 시스템에 속하는 컴포넌트와 그 관계 설계
- 한 패턴에 변형, 요구사항 반영 -> 유사 형태의 다른 패턴으로 변화하는 특징
- GoF 디자인 패턴이 대중적 (생성패턴 5, 구조 패턴 7, 행위패턴 11, 총 23)
- 유형은 다음과 같음
  - 생성 패턴
    - 객체의 생성과 참조 과정을 캡슐화하여, 유연성 더함
    - 추상팩토리: 서로 연관하는 객체들의 그룹으로 생성하여 추상적으로 표현함
    - 빌더: 인스턴스를 조합하여 객체 생성
    - 팩토리 메소드: 상위클래스에서는 인터페이스만 정의, 실제 생성은 서브클래스가 담당
    - 프로토타입: 원본 객체를 복제하여 객체 생성, 비용이 큰 경우 이용
    - 싱글톤: 생성한 객체를 어디서든 참조 가능, 여러 프로세스가 동시 참조는 불가
      - 클래스 내 인스턴스가 하나뿐임을 보장함
  - 구조 패턴
    - 객체들을 조합하여 더 큰 구조로 만들 수 있게 함, 구조 복잡 시스템 개발 용이
    - 어댑터: 호환성 없는 인터페이스 -> 다른 클래스가 이용할 수 있도록 변환
    - 브리지: 기능과 구현을 별도 클래스로 구현, 서로가 독립적 확장 가능
    - 컴포지트: 합성, 객체를 트리 구조로 구성하여, 복합과 단일 객체가 구분 x
    - 데코레이터: 기능 추가 위해 다른 객체 덧붙임
      - 상속을 않고도 객체의 기능을 동적으로 확장 가능
    - 퍼싸드: 더 상위에 인터페이스 구성하여, 서브클레스 간편 사용
      - 서브 클래스 사이 통합 인터페이스 제공하는 Wrapper 객체 필요
    - 플라이웨이트: 인스턴스 가능한 한 공유, 메모리 절약
    - 프록시: 접근 어려운 객체와 연결하려는 객체 사이 인터페이스 역할 수행
      - 네트워크 연결, 대용량 객체로의 접근에 이용
  - 행위 패턴
    - 객체들의 상호작용, 책임 분배 방법 정의
    - 하나의 객체로 수행 불가한 작업을 여러 객체로 분배, 결합도 최소화함
    - 책임연쇄: 요청 처리하는 객체가 둘 이상 존재, 하나가 처리 못하면 다음 객체 책임
    - 커맨드: 요청을 캡슐화, 재이용과 취소 가능하도록 필요 정보를 로그에 남김
    - 인터프리터: 언어의 문법 표현을 정의함
    - 반복자: 접근 잦은 객체에 동일한 인터페이스를 사용
      - 내부 표현 방법 노출 없이 순차적 접근 가능
    - 중재자: 객체들 간 상호작용을 캡슐화, 의존성 줄이고 결합도 감소시킴
      - 서로 존재를 모르는 상태에서도 메시지를 주고받으며 협력 가능
    - 메멘토: 특정 시점의 객체 상태를 객체화, 요청에 따라 해당 시점의 상태로 돌림 (ctrl+z)
    - 옵서버: 객체 상태 변하면 -> 상속된 다른 객체에게 변화 상태 전달 (분산된 시스템 간 이벤트 퍼블리시-섭스크라입)
    - 상태: 객체 상태를 캡슐화하여 이를 참조함, 상태에 따라 다르게 처리할 때
    - 전략: 동일 계열 알고리즘 개별 캡슐화하여 상호 교환함
    - 템플릿메소드: 상위 클래스에서 골격 정의, 하위에서는 세부 처리를 구체화
    - 방문자: 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성
      - 분리된 처리 기능은 각 클래스를 방문하여 수행함





